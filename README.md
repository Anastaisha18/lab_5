# Вавилина Настя ИТ-7 Лабораторная №5

# Задание 1
## Задача 1
### Текст задачи 
 В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими
особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может
быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

### Алгоритм решения
1. Создать интерфейс FractionInterface:
-Объявить метод getRealValue() — вернуть вещественное значение дроби
-Объявить метод setNumerator(int numerator) — установить числитель
-Объявить метод setDenominator(int denominator) — установить знаменатель
2. Создать класс Fraction, реализующий интерфейс:
-Добавить поля numerator и denominator
-В конструкторе Fraction: сохранить числитель; проверить что знаменатель не равен 0; сохранить знаменатель
-Реализовать toString(): вернуть строку "числитель/знаменатель"
-Переопределить equals(): считать дроби равными если одинаковы числитель и знаменатель
3. Создать класс CacheFract, наследующий Fraction:
-Добавить поле cachedValue, изначально null
-Переопределить getRealValue(): если cachedValue == null, вычислить super.getRealValue() и сохранить в кэш
-Переопределить setNumerator() и setDenominator(): вызвать версию родителя; сбросить кэш (cachedValue = null)

5. В методе main:
-Считать числитель и знаменатель от пользователя
-Создать объект CachedFraction и продемонстрировать работу кэша
-Изменить числитель методом setNumerator() и показать пересчет кэша
-Сравнить дроби через equals()
### Тест
<img width="577" height="139" alt="image" src="https://github.com/user-attachments/assets/caa3ace5-c62b-4d34-95f9-4489420b9e1c" />
<img width="368" height="111" alt="image" src="https://github.com/user-attachments/assets/bd527739-cbec-40c9-96cc-53ca39425876" />
<img width="528" height="519" alt="image" src="https://github.com/user-attachments/assets/8e4012f4-ca74-4eb2-8d34-327e21c130d3" />
<img width="366" height="511" alt="image" src="https://github.com/user-attachments/assets/413d6a6c-9f6c-4210-8290-9d10fc0cece6" />



# Задание 2

## Задача 1
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:
public void meow();

### Алгоритм решения
1. Создать интерфейс Meowable:
-Объявить метод meow() — издать звук мяуканья
2. Создать класс Cat, реализующий интерфейс:
-Добавить поля name (имя кота) и meowCount (счетчик мяуканий)
-В конструкторе проверить что имя не пустое
-Реализовать meow(): увеличить счетчик; вывести сообщение формата "имя: мяу!"
-Добавить геттер getMeowCount() для получения количества мяуканий
3. Создать класс Funs со статическим методом:
-Реализовать meowsCare(Meowable... meowables): для каждого объекта вызвать meow() 4 раза
4.В методе main:
-Считать имя кота от пользователя
-Создать объект Cat и передать в Funs.meowsCare()
-Вывести количество совершенных мяуканий
### Тест
<img width="235" height="250" alt="image" src="https://github.com/user-attachments/assets/3d8e80bd-f512-40ee-9275-fadb8cf26371" />


# Задание 3
## Задача 6
### Текст задачи
Составить программу, которая в списке L из каждой группы подряд идущих одинаковых
элементов оставляет только один.
### Алгоритм решения
1. Реализовать метод removeConsecutiveDuplicates() в классе ListOperations
2. Алгоритм:
Создать новый список для результата
Пройти по исходному списку, добавляя только элементы, отличающиеся от предыдущего
Заменить исходный список результатом
- В main():
Ввод чисел через пробел
Преобразование в список целых чисел
Вызов метода удаления дубликатов
Вывод результата
### Тест
<img width="466" height="137" alt="image" src="https://github.com/user-attachments/assets/ac368069-b485-4e74-a733-495da15eedd3" />


# Задание 4
## Задача 5
### Текст задачи
В молочных магазинах города Х продается сметана с жирностью 15, 20 и 25 процентов. В городе
X был проведен мониторинг цен на сметану. Напишите эффективную по времени работы и по
используемой памяти программу, которая будет определять для каждого вида сметаны, сколько
магазинов продают ее дешевле всего. На вход программе сначала подается число магазинов N. В
каждой из следующих N строк находится информация в следующем формате:
<Фирма><Улица><Жирность><Цена>
где <Фирма> – строка, состоящая не более, чем из 20 символов без пробелов, <Улица> – строка,
состоящая не более, чем из 20 символов без пробелов, <Жирность> – одно из чисел – 15, 20 или
25, <Цена> – целое число в диапазоне от 2000 до 5000, обозначающее стоимость одного литра
сметаны в копейках. <Фирма> и <Улица>,<Улица> и <Жирность>, а также <Жирность> и <Цена>
разделены ровно одним пробелом. Пример входной строки:
Перекресток Короленко 25 120
Программа должна выводить через пробел 3 числа – количество магазинов, продающих дешевле
всего сметану с жирностью 15, 20 и 25 процентов. Если какой-то вид сметаны нигде не
продавался, то следует вывести 0.
Пример выходных данных:
12 10 0

### Алгоритм решения
1. Создать класс SourCreamAnalyzer со статическим методом analyze():
-Прочитать файл shops.txt используя ClassLoader.getResourceAsStream()
-Первая строка — количество магазинов n
-Инициализировать переменные min15, min20, min25 максимальными значениями
-Инициализировать счетчики count15, count20, count25 нулями
-Для каждой из n строк: разделить по пробелам; извлечь жирность и цену; обновить минимум и счетчик для соответствующей жирности
-Вывести результат в формате "count15 count20 count25"
2. В методе main:
- Вызвать SourCreamAnalyzer.analyze() без параметров
### Тест
<img width="376" height="513" alt="image" src="https://github.com/user-attachments/assets/a5756f03-a2ff-4cbc-a923-9649ac7f519e" />



# Задание 5
## Задача 9
### Текст задачи
Файл содержит текст на русском языке. Какие цифры встречаются в тексте?

### Алгоритм решения
1. Создать класс DigitAnalyzer со статическим методом findDigitsInText():
-Создать TreeSet<Character> для хранения уникальных отсортированных цифр
-Прочитать файл text_analysis.txt построчно
-Для каждой строки: пройти по всем символам; если символ — цифра, добавить в множество
-Если множество пусто — вывести сообщение об отсутствии цифр
-Иначе — вывести все цифры из множества через пробел
2. В методе main:
-Вызвать DigitAnalyzer.findDigitsInText("text_analysis.txt")
### Тест
<img width="347" height="110" alt="image" src="https://github.com/user-attachments/assets/c7a7fdcb-1214-4ccc-85c1-a201221310cf" />
<img width="298" height="166" alt="image" src="https://github.com/user-attachments/assets/eeaa6f1e-1522-4aae-aa01-8c9874027d3d" />


# Задание 6
## Задача 3
### Текст задачи
Определить, есть ли в очереди L хотя бы один элемент, который равен следующему за ним (по
кругу) элементу (первый элемент считать следующим для последнего).

### Алгоритм решения
1. Создать класс QueueOperations со статическим generic-методом:
-Реализовать hasEqualNeighbors(Queue<T> queue)
-Если очередь пуста или содержит 1 элемент — вернуть false
-Преобразовать очередь в список для доступа по индексу
-Пройти по всем элементам списка: сравнить текущий элемент со следующим (для последнего — с первым)
-Если найден хотя бы один случай равенства — вернуть true
-Иначе — вернуть false
2. В методе main:
-Считать элементы очереди через пробел от пользователя
-Создать очередь и добавить все элементы
-Вызвать QueueOperations.hasEqualNeighbors() и вывести результат
### Тест
<img width="398" height="122" alt="image" src="https://github.com/user-attachments/assets/939ef314-9953-4fa3-a34d-65febc1a6b54" />
<img width="411" height="113" alt="image" src="https://github.com/user-attachments/assets/5ca06519-1688-4152-8b02-54c89ca9b54e" />
<img width="406" height="132" alt="image" src="https://github.com/user-attachments/assets/bb3ae628-253e-4918-8427-8686d076310d" />



# Задание 7
## Задача 2

### Текст задачи 
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]
### Алгоритм решения
1. Создать класс StreamOperations со статическим методом processPeopleFromFile():
-Прочитать файл people.txt построчно в список строк
-Использовать Stream API для обработки:
-Разделить каждую строку по двоеточию на массив parts
-Отфильтровать строки где parts.length == 2 и вторая часть не пустая
-Сгруппировать по номеру (преобразованному в Integer)
-Для значений применить mapping с функцией capitalizeName() для нормализации регистра
-Вывести результат в формате [номер:[имя1, имя2], номер2:[имя3]]
2. Реализовать вспомогательный метод capitalizeName():
-Привести первую букву к верхнему регистру, остальные — к нижнему
3. В методе main:
-Вызвать StreamOperations.processPeopleFromFile()
### Тест
<img width="663" height="127" alt="image" src="https://github.com/user-attachments/assets/7b4501c1-637d-4687-82b7-0c8e99a9a9fc" />
<img width="156" height="200" alt="image" src="https://github.com/user-attachments/assets/4f76a69c-3e82-44a1-9146-d463e8a7e6fb" />
